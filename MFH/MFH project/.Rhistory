if (sum(installed.packages()[,1] %in% "pacman") != 1){
install.packages("pacman")
}
pacman::p_load(sf, data.table, tidyverse, car, msae,
sae, survey, spdep, knitr, MASS, caret)
##load the data
## load the data (relative paths)
survey_dt <- readRDS("data/pov_direct.rds")
rhs_dt    <- readRDS("data/sae_data.rds")
shp_dt    <- readRDS("data/geometries.rds")
survey_dt_long<-survey_dt
#
#I want to make them wide to match easier
#note that the rhs-variables are NOT hh-specific, but area-specific, further, interaction terms are also already included
rhs_dt_wide <- rhs_dt %>%
pivot_wider(
id_cols = c(provlab, prov),              # what identifies an unique observation
names_from = year,            # what to spread across columns
values_from = -c(provlab, prov, year), # what values to fill
names_glue = "{.value}{year}"    # custom column names
)
#
#create hh_identifier and create identification/ overlap between the years
#for now: all hhs are connected for three years, this might not be realistic for the EU-SILC data, but a computation of between the year's variance and covariance is not possible if the variables are not defined on the same probability space. Further, in another file '10-direct-estimate', constructing a panel like this seems to be an option as well.
survey_dt_altered <- survey_dt %>%
group_by(provlab, prov, ea_id, weight, year) %>%
mutate(
dup_counter = row_number()   # 1, 2, 3...
) %>%
ungroup() %>%
mutate(
hh_key = paste(provlab, prov, ea_id, weight, dup_counter, sep = "__"),
hh_id  = as.integer(factor(hh_key))
) %>%
dplyr::select(-hh_key) %>%
pivot_wider(
id_cols = c(hh_id, ea_id, provlab, prov, weight),              # what identifies a unique observation
names_from = year,            # what to spread across columns
values_from = c(income, povline), # what values to fill
names_glue = "{.value}{year}"    # custom column names
)
#combine it all together:
income_dt<-merge(survey_dt_altered, shp_dt, by=c("prov","provlab"))
income_dt<-merge(income_dt, rhs_dt_wide, by=c("prov","provlab"))
#
#
#this datatable is only created to understand the issue of linking households between years better, it will not directly be used
survey_dt_no_overlap <- survey_dt %>%
mutate(hh_id = row_number()) %>%      # create an artificial household_ID, in this case, each observation will be treated as different household
pivot_wider(
id_cols = c(hh_id, ea_id, provlab, prov, weight),              # what identifies a unique observation
names_from = year,            # what to spread across columns
values_from = c(income, povline), # what values to fill
names_glue = "{.value}{year}"    # custom column names
)
#
income_dt_no_overlap<-merge(survey_dt_no_overlap, shp_dt, by=c("prov","provlab"))
income_dt_no_overlap<-merge(income_dt_no_overlap, rhs_dt_wide, by=c("prov","provlab"))
rm(survey_dt_altered, survey_dt_no_overlap, rhs_dt, rhs_dt_wide, shp_dt)
View(survey_dt)
if (sum(installed.packages()[,1] %in% "pacman") != 1){
install.packages("pacman")
}
pacman::p_load(sf, data.table, tidyverse, car, msae,
sae, survey, spdep, knitr, MASS, caret)
##load the data
## load the data (relative paths)
survey_dt <- readRDS("data/pov_direct.rds")
rhs_dt    <- readRDS("data/sae_data.rds")
shp_dt    <- readRDS("data/geometries.rds")
survey_dt_long<-survey_dt
#
#I want to make them wide to match easier
#note that the rhs-variables are NOT hh-specific, but area-specific, further, interaction terms are also already included
rhs_dt_wide <- rhs_dt %>%
pivot_wider(
id_cols = c(provlab, prov),              # what identifies an unique observation
names_from = year,            # what to spread across columns
values_from = -c(provlab, prov, year), # what values to fill
names_glue = "{.value}{year}"    # custom column names
)
View(rhs_dt_wide)
View(rhs_dt)
View(rhs_dt_wide)
survey_dt_altered <- survey_dt %>%
group_by(provlab, prov, ea_id, weight, year) %>%
mutate(
dup_counter = row_number()   # 1, 2, 3...
) %>%
ungroup() %>%
mutate(
hh_key = paste(provlab, prov, ea_id, weight, dup_counter, sep = "__"),
hh_id  = as.integer(factor(hh_key))
) %>%
dplyr::select(-hh_key) %>%
pivot_wider(
id_cols = c(hh_id, ea_id, provlab, prov, weight),              # what identifies a unique observation
names_from = year,            # what to spread across columns
values_from = c(income, povline), # what values to fill
names_glue = "{.value}{year}"    # custom column names
)
View(survey_dt_altered)
#combine it all together:
income_dt<-merge(survey_dt_altered, shp_dt, by=c("prov","provlab"))
income_dt<-merge(income_dt, rhs_dt_wide, by=c("prov","provlab"))
#
View(income_dt)
survey_dt_no_overlap <- survey_dt %>%
mutate(hh_id = row_number()) %>%
survey_dt_no_overlap <- survey_dt %>%
mutate(hh_id = row_number()) %>%      # create an artificial household_ID, in this case, each observation will be treated as different household
pivot_wider(
id_cols = c(hh_id, ea_id, provlab, prov, weight),              # what identifies a unique observation
names_from = year,            # what to spread across columns
values_from = c(income, povline), # what values to fill
names_glue = "{.value}{year}"    # custom column names
)
#
#
#this datatable is only created to understand the issue of linking households between years better, it will not directly be used
survey_dt_no_overlap <- survey_dt %>%
mutate(hh_id = row_number()) %>%      # create an artificial household_ID, in this case, each observation will be treated as different household
pivot_wider(
id_cols = c(hh_id, ea_id, provlab, prov, weight),              # what identifies a unique observation
names_from = year,            # what to spread across columns
values_from = c(income, povline), # what values to fill
names_glue = "{.value}{year}"    # custom column names
)
#
income_dt_no_overlap<-merge(survey_dt_no_overlap, shp_dt, by=c("prov","provlab"))
income_dt_no_overlap<-merge(income_dt_no_overlap, rhs_dt_wide, by=c("prov","provlab"))
View(survey_dt_no_overlap)
View(survey_dt_altered)
rm(survey_dt_altered, survey_dt_no_overlap, rhs_dt, rhs_dt_wide, shp_dt)
income_dt_no_overlap <-
income_dt_no_overlap |>
mutate(poor_2012 = ifelse(income2012 < povline2012, 1, 0),
poor_2013 = ifelse(income2013 < povline2013, 1, 0),
poor_2014 = ifelse(income2014 < povline2014, 1, 0))
View(income_dt)
View(income_dt_no_overlap)
View(income_dt)
View(income_dt_no_overlap)
View(survey_dt)
View(survey_dt_long)
View(survey_dt)
View(income_dt)
View(income_dt_no_overlap)
View(income_dt)
View(income_dt_no_overlap)
View(income_dt_no_overlap)
names(income_dt_no_overlap)
View(income_dt_no_overlap)
View(dplyr::select(income_dt_no_overlap, hh_id, prov, provlab, poor_2012))
#define design object
design_income_dt_no_overlap <- svydesign(ids = ~ea_id, # PSU-variable, if not available ~1 instead
weights = ~weight, # survey weights
data = income_dt_no_overlap)
dir_est_domain_2012 <- svyby(
formula    = ~poor_2012,
by         = ~provlab+prov,
design     = design_income_dt_no_overlap,
FUN        = svymean,
covariance = TRUE,
na.rm=TRUE
)%>%
mutate(mse_2012=se^2)%>%
mutate(se_2012=se)%>%
dplyr::select(-se)
#
dir_est_domain_2013 <- svyby(
formula    = ~poor_2013,
by         = ~provlab+prov,
design     = design_income_dt_no_overlap,
FUN        = svymean,
covariance = TRUE,
na.rm=TRUE
)%>%
mutate(mse_2013=se^2)%>%
mutate(se_2013=se)%>%
dplyr::select(-se)
#
dir_est_domain_2014 <- svyby(
formula    = ~poor_2014,
by         = ~provlab+prov,
design     = design_income_dt_no_overlap,
FUN        = svymean,
covariance = TRUE,
na.rm=TRUE
)%>%
mutate(mse_2014=se^2)%>%
mutate(se_2014=se)%>%
dplyr::select(-se)
#
#combine them all:
dir_est_domain_all_years<-merge(dir_est_domain_2012,dir_est_domain_2013, by=c("prov","provlab"))
dir_est_domain_all_years<-merge(dir_est_domain_all_years,dir_est_domain_2014, by=c("prov","provlab"))
#get number of observations here, later needed for smoothing of variance estimate
sampsize_dt <-
income_dt_no_overlap |>
group_by(prov) |>
summarize(N_2012 = sum(!is.na(poor_2012)),
N_2013 = sum(!is.na(poor_2013)),
N_2014 = sum(!is.na(poor_2014))
)
#
#combine with direct estimates
dir_est_domain_all_years<-merge(dir_est_domain_all_years,sampsize_dt, by="prov" )
#some housekeeping
rm(sampsize_dt,dir_est_domain_2012,dir_est_domain_2013,dir_est_domain_2014,design_income_dt_no_overlap)
```
names(income_dt_no_overlap)
which(names(income_dt_no_overlap) == "" | is.na(names(income_dt_no_overlap)))
which(trimws(names(income_dt_no_overlap)) == "")
names(income_dt_no_overlap)[which(trimws(names(income_dt_no_overlap)) == "")]
#include poverty indicators for each year
income_dt_no_overlap <-
income_dt_no_overlap |>
mutate(poor_2012 = ifelse(income2012 < povline2012, 1, 0),
poor_2013 = ifelse(income2013 < povline2013, 1, 0),
poor_2014 = ifelse(income2014 < povline2014, 1, 0))
#define design object
design_income_dt_no_overlap <- svydesign(ids = ~ea_id, # PSU-variable, if not available ~1 instead
weights = ~weight, # survey weights
data = income_dt_no_overlap)
#
#as svyby's na.rm is excluding observations where at least one of formula's value is na, handing over poor_2012+poor_2013+poor_2014 would lead to no observation being included, leading to only 0s. Therefore: handle all of them individually
dir_est_domain_2012 <- svyby(
formula    = ~poor_2012,
by         = ~provlab+prov,
design     = design_income_dt_no_overlap,
FUN        = svymean,
covariance = TRUE,
na.rm=TRUE
)%>%
mutate(mse_2012=se^2)%>%
mutate(se_2012=se)%>%
dplyr::select(-se)
#
dir_est_domain_2013 <- svyby(
formula    = ~poor_2013,
by         = ~provlab+prov,
design     = design_income_dt_no_overlap,
FUN        = svymean,
covariance = TRUE,
na.rm=TRUE
)%>%
mutate(mse_2013=se^2)%>%
mutate(se_2013=se)%>%
dplyr::select(-se)
#
dir_est_domain_2014 <- svyby(
formula    = ~poor_2014,
by         = ~provlab+prov,
design     = design_income_dt_no_overlap,
FUN        = svymean,
covariance = TRUE,
na.rm=TRUE
)%>%
mutate(mse_2014=se^2)%>%
mutate(se_2014=se)%>%
dplyr::select(-se)
dir_est_domain_all_years<-merge(dir_est_domain_2012,dir_est_domain_2013, by=c("prov","provlab"))
dir_est_domain_all_years<-merge(dir_est_domain_all_years,dir_est_domain_2014, by=c("prov","provlab"))
View(dir_est_domain_all_years)
sampsize_dt <-
income_dt_no_overlap |>
group_by(prov) |>
summarize(N_2012 = sum(!is.na(poor_2012)),
N_2013 = sum(!is.na(poor_2013)),
N_2014 = sum(!is.na(poor_2014))
)
View(sampsize_dt)
dir_est_domain_all_years<-merge(dir_est_domain_all_years,sampsize_dt, by="prov" )
View(dir_est_domain_all_years)
rm(sampsize_dt,dir_est_domain_2012,dir_est_domain_2013,dir_est_domain_2014,design_income_dt_no_overlap)
```
## quickly creating the poverty indicator
income_dt_no_overlap <-
income_dt_no_overlap |>
mutate(poor_2012 = ifelse(income2012 < povline2012, 1, 0),
poor_2013 = ifelse(income2013 < povline2013, 1, 0),
poor_2014 = ifelse(income2014 < povline2014, 1, 0))
### creating a survey object
design_obj <- svydesign(ids = ~ea_id, ###replace this argument with the PSU, cluster or enumeration area variable as the case maybe if available, if not use ~1 instead
weights = ~weight, ### survey weights
data = income_dt_no_overlap)
#as above, again have to do each period on its own, but now, with a loop
## code running variables and input
vars <- c("poor_2012", "poor_2013", "poor_2014")
out_names <- c("v1_national_hh", "v2_national_hh", "v3_national_hh")
v_national_hh <- list()# empty list for results
for (i in seq_along(vars)) {
this_var <- vars[i]
this_name <- out_names[i]
# 1. compute svymean
tmp <- svymean(as.formula(paste0("~", this_var)),
design_obj, na.rm = TRUE)
# 2. extract covariance matrix
vc <- vcov(tmp)
# 3. convert to numeric: variance + lower triangular covariance
vc_vec <- as.numeric(c(diag(vc), vc[lower.tri(vc, diag = FALSE)]))
# 4. store result
v_national_hh[[this_name]] <- vc_vec
}
v_national_hh
### Next, I will create a dataframe that has each domain-level name and index as well as these variances as columns plus the domain-level number of observation for each year
all_var_hat_domain_dt<-dir_est_domain_all_years%>%
dplyr::select(c(prov, provlab, N_2012,N_2013,N_2014))%>%
unique()
all_var_hat_domain_dt$v1_national_hh<-v_national_hh[["v1_national_hh"]]
all_var_hat_domain_dt$v2_national_hh<-v_national_hh[["v2_national_hh"]]
all_var_hat_domain_dt$v3_national_hh<-v_national_hh[["v3_national_hh"]]
